# 第二章



Verilog HDL 是一门硬件描述语言(Hardware Description Language).

## 语言要素

- 空白符

  空白符包括空格，Tab，回车和换行，这些字符将在编译和综合时被忽略

- 注释符

  和C/C++一致，单行注释使用`//`，多行注释使用`/* */`包裹

- 标识符

  用标识符命名信号、模块、参数等，命名规则和C/C++类似，必须是字母数字\$和\_的组合，区分大小写，第一个字符必须是字母和\_。

- 转义标识符

  反斜杠加一个非法字符可以成为一个合法的标识符，没啥用

- 关键字

- 数值

  - 逻辑状态

    `0` 逻辑0，低电平

    `1` 逻辑1，高电平

    `X/x` 不定态

    `Z/z` 高阻态

  - 整数

    格式：`[+/-]<size>'<base_format><number>` 

    `size` 说明了二进制位的数目，不可以是表达式

    `base_format` 可以为二进制(b/B)，八进制(o/O)，十进制(d/D)，十六进制(h/H)E

    此外，nunber中可以使用下划线隔开，使数字易读

    例如：`4'b1001`表示四位二进制数1001

## 数据类型

- 物理数据类型：连线型，寄存器型和存储器型

- 信号强度：信号强度表示数字电路中不同强度的驱动源，用来解决不同驱动强度存在的赋值冲突

  驱动强度从强到弱分别为：
  
  | 驱动强度(strength) | 名称       | 类型 | 备注 |
  | ------------------ | ---------- | ---- | ---- |
  | supply             | 电源级驱动 | 驱动 |      |
  | strong             | 强驱动     | 驱动 |      |
  | pull               | 上拉驱动   | 驱动 |      |
  | week               | 弱驱动     | 驱动 |      |
  | large              | 大容性     | 存储 |      |
  | medium             | 中性驱动   | 存储 |      |
  | small              | 小容性     | 存储 |      |
  | highz              | 高阻       | 高阻 |      |


- 连线型

  | 连线和数据类型(declaration) | 说明                   |
  | --------------------------- | ---------------------- |
  | wire/tri                    | 默认值，标准连线       |
  | wor/trior                   | 多重驱动时线或         |
  | wand/trand                  | 多重驱动时线与         |
  | trireg                      | 具有电荷保持特性的连线 |
  | tri1                        | 上拉电阻               |
  | tri0                        | 下拉电阻               |
  | supply1                     | 电源1                  |
  | supply0                     | 电源0                  |

  声明方式：`<declaration> [(strength)] [range] [delay] <variables_list>`

  - declaration 连线类型
  - strength 驱动强度
  - range 指定数据是标量还是矢量，若默认则为1位标量，超过一位则为矢量
  - delay 仿真延迟时间

  例如：`wire(pull1,strong0) c`定义了01驱动强度不同的连线型变量c

- 寄存器类型

  `reg`型是数据存储的抽象类型，对应的电路有状态保持作用。这种类型用于行为级描述，由过程赋值语句赋值。

  声明方式：`reg [range] <标识符>`

- 存储器型

- 抽象数据类型

  integer，time， real，parameter

## 运算符和表达式

Verilog 运算符及其优先级和C语言类似，此外，还支持按位同或运算符`^~`，器优先级与按位异或一致。

- +，-，\*，/，%

  -  算术表达式运算结果的位宽由最长的操作数决定。在赋值语句下，算数结果的位宽由目标长度决定。

- \> ， <， >=, <=

  - 关系运算符的结果是一个1bit信号 

- \=\=， != , \=\=\=, !\=\=

  - 相等运算符\=\=和!\=当比较不定态和高阻态时，结果时补丁态
  - 全等运算符在信号完全相等时返回1，其余情况返回0

  为了电路的高可靠性，不要比较不同位宽的信号，也不要比较不定状态的信号

- 。。。

- 连接运算符`{...}`和赋值运算符`{{...}}`

- 连接运算符将不同信号中的某些位重新组合成一个新的信号，例如：

  `a = {b,c}`将b，c信号组合成一个新的信号赋值给a

- 复制运算符将相同的信号重复。

## 模块

模块`module`是Verilog语言的基本单元，代表一个基本的功能块，用于描述某个设计的功能或结构以及其他通讯模块的外部端口。

~~~verilog
module name(/*端口列表*/); //模块定义行，必须以分号结束
    
    //端口定义
    //定义端口列表的信号是输入(input)、输出(output)和双向端口(inout)及其位宽
    //...
    
    //数据类型说明
    //说明模块内部用到的信号，调用的模块等声明语句和功能定义
    //...
    
    //逻辑功能描述
    //用来产生各种逻辑，主要包括initial，always，其他子模块实例化语句，门实例化语句，用户自定义原语实例化语句、连续赋值语句、函数和任务。
    //...
    
endmodule//模块结束行
~~~

例如：

~~~verilog
//D触发器的模块描述
module dff(din, clk, q);//说明了模块名dff，信号din，clk和q
    
    input din;//输入信号din
    input clk;//输入信号clk
    output q;//输出信号q
    
    reg q;
    
    always@(posedge clk) begin
    	q <= din
    end
    
endmodule
~~~

- 端口
  - 端口可以是输入(input)，输出(output)和双向(inout)
  - 模块引用时的端口对应形式：
    1. 按照端口顺序连接，类似C语言函数调用时的参数列表。例如`dff(a, b, c)`
    2. 表明端口名和连接的信号名。例如`dff(din(a), clk(b), q(c))`

# 第三章

## 数据流建模

- 连续赋值语句

  连续赋值的目标类型主要是标量线网和向量线网两种。

  1. 标量线网，如 `wire a,b`
  2. 向量线网，如`wire[3:0] a,b`

- 显式连续赋值

  信号的定义和连续赋值分成多行

  `<net_declaration><range><name>`

  `assign [#<delay>]<name> = <assignment_exp>`

- 隐式连续赋值

  信号定义时就指定了连续赋值

## 行为级建模

| 类别     | 语句块              | 可综合性 |
| -------- | ------------------- | -------- |
| 过程语句 | initial             |          |
|          | always              | 可综合   |
| 语句块   | 串行语句块begin-end | 可综合   |
|          | 并行语句块fork-join |          |
| 赋值语句 | 过程连续赋值assign  |          |
|          | 过程赋值=、< =      | 可综合   |
| 条件语句 | if-else             | 可综合   |
|          | case、casex、casez  | 可综合   |
| 循环语句 | forever             |          |
|          | repeat              |          |
|          | while               |          |

- initial

  ~~~verilog
  module xxx();
      initial begin
          //...
      end
  endmodule
  ~~~

- always

  从语法层面上看，相对于initial，always语句的触发状态一直存在，只要满足always后的敏感事件列表，就执行过程块。

  ~~~Verilog
  always@(/*敏感事件表*/)
      /*语句块*/
  ~~~
  
  敏感事件表中没有”与“的概念，敏感时间表中任何一个信号发生变化时，语句块会被执行。

